#Advanced Topics in Web Development 2 Assignment

####Student Name: Andrew Weng Yew Leong

####ID: 15034579

##

###Assignment file Links:

#### Google Chart: Final Output (html)

1. Scatter Chart [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/scatterChart.html): `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/scatterChart.html`

2. Line Chart [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/lineChart.html): `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/lineChart.html`

##

#### All server-side phps Source code files (*phps)

1. Scatter Chart no2xml to json [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_2_json_scatterChart.phps): `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_2_json_scatterChart.phps`

2. Line Chart no2xml to json [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_2_json_lineChart.phps): `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_2_json_lineChart.phps`

3. Xml to no2.xml [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_to_no2.phps): `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_to_no2.phps`

4. Csv to xml [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/csv_to_xml.phps): `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/csv_to_xml.phps`

##

####No2.xml to Json / Google chart server-side (php)

1. Scatter chart php [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_2_json_scatterChart.php): `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_2_json_scatterChart.php`

2. Line chart php [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_2_json_lineChart.php): `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_2_json_lineChart.php`

#### Xml to No2.xml (php)

1. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_to_no2.php) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/xml_to_no2.php`

####Csv to Xml (php)

1. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/csv_to_xml.php) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/csv_to_xml.php`

####6 locations_No2 (xml)

1. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/brislington_no2.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/brislington_no2.xml`

2. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/fishponds_no2.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/fishponds_no2.xml`

3. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/newfoundland_way_no2.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/newfoundland_way_no2.xml`

4. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/parson_st_no2.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/parson_st_no2.xml`

5. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/rupert_st_no2.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/rupert_st_no2.xml`

6. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/wells_road_no2.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/wells_road_no2.xml`

####6 locations un-normalized (xml)

1. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/brislington.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/brislington.xml`

2. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/fishponds.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/fishponds.xml`

3. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/newfoundland_way.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/newfoundland_way.xml`

4. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/parson_st.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/parson_st.xml`

5. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/rupert_st.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/rupert_st.xml`

6. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/wells_road.xml) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/wells_road.xml`

####Air Quality file (csv)

1. [open link](http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/air_quality.csv) `http://isa.cems.uwe.ac.uk/~aw2-leong/atwd2/assignment/air_quality.csv`

##

#Final Task: Report Discussion
###1) Why and when to use streaming parsers instead of DOM parsers?

There are many kinds of stream parsers. There are the XML Reader, StAX (Streaming API for XML) and the SAX (Simple API for XML). Stream parsers provides an alternative method to the DOM (Document Object Model) parser approach like SimpleXML for reading data of XML documents. Stream parser like the SAX parser is an event-based XML parser that launches an event and sends callbacks to the user whenever it meets structural bits of data like the opening tags, elements and attributes. The benefit of this is it doesn't have concerns for the input file size.

It parses through the XML file on a step-by-step basis which makes it a better option for parsing large XML documents compared to the DOM. When there is a need to parse huge XML documents, it is highly recommended to use stream parsers like the SAX instead of the DOM. The reason behind is because the stream parsers don't need to fully load the whole XML file into the memory which means it has no memory constraints, whereas the DOM is required to parse the complete XML document into memory and the DOM tree-based structure that represents the nodes in the xml will be generated and returned. 

Therefore, the DOM requires more memory and if you are using the DOM to read huge XML files, based on the memory constraints it would either take a long time to load or it would not even be able to load the file since the memory consumption is huge. So, the DOM suffers from scalability issues and become expensive for huge files. 

However, the DOM is a much more easier approach to use, as it can perform DOM functionalities that are available like Xpath, being able to freely manipulate the nodes in the trees like; insert or delete nodes and being able to transverse the tree in any direction. In contrast, Stream parsers can't perform those DOM functions like xpath, insert / delete nodes or transverse trees. In addition, Stream parsers reads the XML document from top to bottom, so it can't perform backwards navigation. 

Therefore, if the XML file is relatively small, it would be ideal to use the DOM parser as it will be quite fast since it parses the whole XML document in memory and the main benefit of it is that its easy to query or modify any part of the document which provides ease of navigation.       

###2) How you might extend the charting and data visualisation further ?

##### * Implementing Google chart's Dashboards and Controls API for customization:

While working with the Google Charts API, I came across the more advanced functions for customizing charts. The [Dashboards](https://developers.google.com/chart/interactive/docs/gallery/controls#dashboardobject) helps to organize and manage multiple charts with the same data. I can use this API to combine my Scatter Chart and Line Chart together into one page instead of having it on separate web pages, so that the user can have a dropdown list selection of different chart. The Dashboard acts as a great management tool to handle the controls and holding the data table for drawing and passing the data to the charts that are under the Dashboard.  The [code example](http://cs.wellesley.edu/~qtw/slides/googlecharts2.html#slide10) below shows the Dashboard binding the controls' functionalities like string filter; for specific keyword query, etc and then it draws the chart.

    var dashboard = new google.visualization.Dashboard(   
       	document.getElementById('dashboard_div'));
      //bind the controls functions to the graph  
      dashboard.bind([stringfilter, slidersum, slidernum, slidercyc, catwin, catparty, catinc, catst], wrapper);   
      //render the graph and controls   
      dashboard.draw(data);

Furthermore, adding controls gives better visualization to the user, since it uses the [ControlWrapper](https://developers.google.com/chart/interactive/docs/gallery/controls#controlwrapperobject) as part of the dashboard  which provides a simple approach for displaying specific graphical elements of the data visualization and having more controls where the user can interact with the chart. An example of the [code](http://jsfiddle.net/keen/kuqod2ya/) below shows the controls for a range slider where it can filter by which column to modify and what columns to display to the user. This will provide a more detailed visualization of data to the users.  

    var Slider = new google.visualization.ControlWrapper({
	    'controlType': 'ChartRangeFilter',
	    'containerId': 'control_div',
	    'options': {
	    'filterColumnIndex': 1,
	    'ui': {
	      'chartType': 'LineChart',
	      'chartOptions': {
	    'chartArea': {'width': '90%'},
	    'hAxis': {'baselineColor': 'none'}
	      },
	      // Display a single series that shows the closing value of the stock.
	      // Thus, this view has two columns: the date (axis) and the stock value (line series).
	      'chartView': {
	    'columns': [1, 2]
	      }  
	    } 
	    }
     }); 
    
##### * Implementing Calender for all dates of user selection: 

In my current google line chart, I have a dropdownlist of dates where the user can select and since it doesn't contain all the dates of the year, I would use Jquery and CSS plugin to create the calender input like the [code example](http://jsfiddle.net/manikoth/Fa8Xx/) below. In addition, I would also implement an alert function like `if (data == null){alert("no data found")}` where if the user selects some of the location and the chosen date that doesn't contain any data.     

`<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.18/themes/mint-choc/jquery-ui.css"></script>`

`$( "#datepicker" ).datepicker();` 

##### * Dynamically update Google Chart:

I would extend my chart by populating new data to the existing chart, so that the chart will draw again at certain periods of the day to get dynamically updated when there's modification of the data. I would use the Jquery AJAX call method to auto-refresh the chart under specific time intervals. It's also possible to have real-time and interactive charts. I found a great [tutorial](http://lovelearning9.blogspot.co.uk/2016/04/google-charts-great-way-to-draw.html) that shows how to make the Google Chart to draw a real-time chart where it can read data from REST API to automatically refresh the chart. The code below shows AJAX is used to read the JSON data from REST API to a variable that will be converted to the format of Google Chart.

![](https://3.bp.blogspot.com/-mDEXXplzsMU/VxJX4bZMDHI/AAAAAAAABJs/5PVTGKRBdho_GOo1GJx0hcMaBk-uKJq1ACLcB/s1600/Screen%2BShot%2B2016-04-16%2Bat%2B11.16.48%2BPM.png) 

By using the `setRefreshInterval()` function, it will set up the refresh effect of Google Chart to draw the it again.

![](https://3.bp.blogspot.com/-gZzeXm2jOtY/VxJYzWe-mhI/AAAAAAAABJ0/zGMWU6Z0LaQb5Hb8bpcq42RDeTpG8zmQACLcB/s1600/Screen%2BShot%2B2016-04-16%2Bat%2B11.22.39%2BPM.png) 

    